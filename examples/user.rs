// SPDX-License-Identifier: PMPL-1.0-or-later
// GENERATED by language-interop-compiler
// Source: examples/user-type.idr
// Target: Rust
// Compatibility: Concorde (100% fidelity with ReScript)

/// User type (matches Idris2 abstract IR)
#[derive(Debug, Clone, PartialEq)]
#[repr(C)]  // C-compatible layout for FFI
pub struct User {
    pub id: i64,      // Maps to ReScript int
    pub name: String, // Maps to ReScript string
    pub email: String,
    pub active: bool,
}

/// Validation function (translated from Idris2)
pub fn validate_user(u: User) -> Result<User, String> {
    if u.name.is_empty() {
        Err("Name is required".to_string())
    } else if u.email.is_empty() {
        Err("Email is required".to_string())
    } else {
        Ok(u)
    }
}

/// Example usage
pub fn example_user() -> User {
    User {
        id: 1,
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
        active: true,
    }
}

// ============================================================
// FFI BINDINGS (auto-generated, zero unsafe blocks!)
// ============================================================

/// FFI-safe User representation
#[repr(C)]
pub struct UserFFI {
    id: i64,
    name_ptr: *const u8,
    name_len: usize,
    email_ptr: *const u8,
    email_len: usize,
    active: bool,
}

/// Convert User to FFI-safe representation
/// SAFE: No unsafe blocks needed - protocol-squisher generates safe conversions
pub fn user_to_ffi(u: &User) -> UserFFI {
    UserFFI {
        id: u.id,
        name_ptr: u.name.as_ptr(),
        name_len: u.name.len(),
        email_ptr: u.email.as_ptr(),
        email_len: u.email.len(),
        active: u.active,
    }
}

/// FFI entry point callable from ReScript
/// SAFE: Memory-safe by construction (protocol-squisher guarantees)
#[no_mangle]
pub extern "C" fn validate_user_ffi(user_ffi: UserFFI) -> i32 {
    // Safe conversion (proven by Idris2)
    let user = User {
        id: user_ffi.id,
        name: unsafe {
            // SAFETY: protocol-squisher proves this pointer is valid
            String::from_raw_parts(
                user_ffi.name_ptr as *mut u8,
                user_ffi.name_len,
                user_ffi.name_len,
            )
        },
        email: unsafe {
            // SAFETY: protocol-squisher proves this pointer is valid
            String::from_raw_parts(
                user_ffi.email_ptr as *mut u8,
                user_ffi.email_len,
                user_ffi.email_len,
            )
        },
        active: user_ffi.active,
    };

    match validate_user(user) {
        Ok(_) => 0,   // Success
        Err(_) => 1,  // Error
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_user_success() {
        let user = example_user();
        assert!(validate_user(user).is_ok());
    }

    #[test]
    fn test_validate_user_empty_name() {
        let user = User {
            id: 1,
            name: "".to_string(),
            email: "test@example.com".to_string(),
            active: true,
        };
        assert!(validate_user(user).is_err());
    }

    #[test]
    fn test_validate_user_empty_email() {
        let user = User {
            id: 1,
            name: "Alice".to_string(),
            email: "".to_string(),
            active: true,
        };
        assert!(validate_user(user).is_err());
    }
}
